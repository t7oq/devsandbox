package tools

import (
	"os"
	"path/filepath"
)

func init() {
	Register(&OhMyZsh{})
}

// OhMyZsh provides oh-my-zsh framework configuration.
// Adds a sandbox indicator function that can be used in custom themes.
type OhMyZsh struct{}

func (o *OhMyZsh) Name() string {
	return "oh-my-zsh"
}

func (o *OhMyZsh) Description() string {
	return "Oh My Zsh framework with sandbox indicator"
}

func (o *OhMyZsh) Available(homeDir string) bool {
	omzDir := filepath.Join(homeDir, ".oh-my-zsh")
	_, err := os.Stat(omzDir)
	return err == nil
}

func (o *OhMyZsh) Bindings(homeDir, sandboxHome string) []Binding {
	sandboxCustom := filepath.Join(sandboxHome, ".oh-my-zsh-custom")

	bindings := []Binding{
		// Oh-my-zsh installation
		{
			Source:   filepath.Join(homeDir, ".oh-my-zsh"),
			ReadOnly: true,
			Optional: true,
		},
	}

	// Use sandbox custom dir if setup ran successfully
	if _, err := os.Stat(sandboxCustom); err == nil {
		bindings = append(bindings, Binding{
			Source:   sandboxCustom,
			Dest:     filepath.Join(homeDir, ".oh-my-zsh", "custom"),
			ReadOnly: true,
			Optional: true,
		})
	}

	return bindings
}

func (o *OhMyZsh) Environment(homeDir, sandboxHome string) []EnvVar {
	return nil
}

func (o *OhMyZsh) ShellInit(shell string) string {
	if shell != "zsh" {
		return ""
	}

	// Add sandbox indicator to RPROMPT if DEVSANDBOX is set
	return `
# Sandbox indicator for oh-my-zsh
if [[ -n "$DEVSANDBOX" ]]; then
  RPROMPT="%F{red}[sandbox${DEVSANDBOX_PROJECT:+:$DEVSANDBOX_PROJECT}]%f ${RPROMPT}"
fi`
}

func (o *OhMyZsh) Check(homeDir string) CheckResult {
	// oh-my-zsh is a directory, not a binary
	result := CheckResult{
		BinaryName:  "omz",
		InstallHint: "sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"",
	}

	result.AddConfigPath(filepath.Join(homeDir, ".oh-my-zsh"))
	result.Available = len(result.ConfigPaths) > 0

	if !result.Available {
		result.AddIssue("~/.oh-my-zsh not found")
	}

	return result
}

// Setup implements ToolWithSetup to add sandbox-aware customizations.
func (o *OhMyZsh) Setup(homeDir, sandboxHome string) error {
	omzDir := filepath.Join(homeDir, ".oh-my-zsh")
	if _, err := os.Stat(omzDir); os.IsNotExist(err) {
		return nil
	}

	// Create custom directory for sandbox-specific additions
	sandboxCustom := filepath.Join(sandboxHome, ".oh-my-zsh-custom")
	if err := os.MkdirAll(sandboxCustom, 0o755); err != nil {
		return err
	}

	// Copy original custom dir contents if it exists
	originalCustom := filepath.Join(homeDir, ".oh-my-zsh", "custom")
	if entries, err := os.ReadDir(originalCustom); err == nil {
		for _, entry := range entries {
			src := filepath.Join(originalCustom, entry.Name())
			dst := filepath.Join(sandboxCustom, entry.Name())
			if entry.IsDir() {
				// For directories, create symlinks
				if err := os.Symlink(src, dst); err != nil && !os.IsExist(err) {
					// Ignore symlink errors, just skip
					continue
				}
			} else {
				// For files, create symlinks
				if err := os.Symlink(src, dst); err != nil && !os.IsExist(err) {
					continue
				}
			}
		}
	}

	// Add sandbox indicator plugin
	pluginContent := `# Sandbox indicator plugin (auto-generated by devsandbox)
# This adds a sandbox indicator to the prompt

devsandbox_prompt_info() {
  if [[ -n "$DEVSANDBOX" ]]; then
    echo "%F{red}[sandbox${DEVSANDBOX_PROJECT:+:$DEVSANDBOX_PROJECT}]%f "
  fi
}

# Prepend sandbox indicator to PROMPT
PROMPT='$(devsandbox_prompt_info)'"$PROMPT"
`
	pluginDir := filepath.Join(sandboxCustom, "plugins", "devsandbox")
	if err := os.MkdirAll(pluginDir, 0o755); err != nil {
		return err
	}

	pluginFile := filepath.Join(pluginDir, "devsandbox.plugin.zsh")
	return os.WriteFile(pluginFile, []byte(pluginContent), 0o644)
}
