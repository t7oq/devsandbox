package tools

import (
	"os"
	"os/exec"
	"path/filepath"
)

func init() {
	Register(&Tmux{})
}

// Tmux provides tmux terminal multiplexer configuration.
// Can display sandbox indicator in status bar.
type Tmux struct{}

func (t *Tmux) Name() string {
	return "tmux"
}

func (t *Tmux) Description() string {
	return "Tmux terminal multiplexer with sandbox indicator"
}

func (t *Tmux) Available(homeDir string) bool {
	// Check if tmux is installed and user has a config
	if _, err := exec.LookPath("tmux"); err != nil {
		return false
	}

	// Check for tmux config
	paths := []string{
		filepath.Join(homeDir, ".tmux.conf"),
		filepath.Join(homeDir, ".config", "tmux", "tmux.conf"),
	}

	for _, p := range paths {
		if _, err := os.Stat(p); err == nil {
			return true
		}
	}

	return false
}

func (t *Tmux) Bindings(homeDir, sandboxHome string) []Binding {
	sandboxTmuxConf := filepath.Join(sandboxHome, ".tmux.conf")

	bindings := []Binding{
		// Tmux plugins (tpm)
		{
			Source:   filepath.Join(homeDir, ".tmux", "plugins"),
			ReadOnly: true,
			Optional: true,
		},
		{
			Source:   filepath.Join(homeDir, ".config", "tmux", "plugins"),
			ReadOnly: true,
			Optional: true,
		},
	}

	// Use sandbox tmux config if setup ran successfully
	if _, err := os.Stat(sandboxTmuxConf); err == nil {
		bindings = append(bindings, Binding{
			Source:   sandboxTmuxConf,
			Dest:     filepath.Join(homeDir, ".tmux.conf"),
			ReadOnly: true,
			Optional: true,
		})
	} else {
		// Fall back to original configs
		bindings = append(bindings,
			Binding{
				Source:   filepath.Join(homeDir, ".tmux.conf"),
				ReadOnly: true,
				Optional: true,
			},
			Binding{
				Source:   filepath.Join(homeDir, ".config", "tmux", "tmux.conf"),
				ReadOnly: true,
				Optional: true,
			},
		)
	}

	return bindings
}

func (t *Tmux) Environment(homeDir, sandboxHome string) []EnvVar {
	return nil
}

func (t *Tmux) ShellInit(shell string) string {
	return ""
}

func (t *Tmux) Check(homeDir string) CheckResult {
	result := CheckResult{
		BinaryName:  "tmux",
		InstallHint: "Install via system package manager",
	}

	path, err := exec.LookPath("tmux")
	if err != nil {
		result.Issues = append(result.Issues, "tmux binary not found in PATH")
		return result
	}

	result.BinaryPath = path

	// Check config paths
	configPaths := []string{
		filepath.Join(homeDir, ".tmux.conf"),
		filepath.Join(homeDir, ".config", "tmux", "tmux.conf"),
		filepath.Join(homeDir, ".tmux", "plugins"),
	}

	for _, p := range configPaths {
		if _, err := os.Stat(p); err == nil {
			result.ConfigPaths = append(result.ConfigPaths, p)
		}
	}

	result.Available = len(result.ConfigPaths) > 0

	if !result.Available {
		result.Issues = append(result.Issues, "no tmux config found")
	}

	return result
}

// Setup implements ToolWithSetup to generate the sandbox-aware tmux config.
func (t *Tmux) Setup(homeDir, sandboxHome string) error {
	// Find existing tmux config
	configPaths := []string{
		filepath.Join(homeDir, ".tmux.conf"),
		filepath.Join(homeDir, ".config", "tmux", "tmux.conf"),
	}

	var originalContent []byte
	for _, p := range configPaths {
		if content, err := os.ReadFile(p); err == nil {
			originalContent = content
			break
		}
	}

	if originalContent == nil {
		return nil
	}

	sandboxTmuxConf := filepath.Join(sandboxHome, ".tmux.conf")

	// Append sandbox indicator to status bar
	indicator := `

# Sandbox indicator (auto-generated by devsandbox)
# Shows [SANDBOX] in status bar when DEVSANDBOX is set
if-shell '[ -n "$DEVSANDBOX" ]' {
  set -g status-left "#[fg=red,bold][SANDBOX] #[default]#{status-left}"
  set -g status-style "bg=colour52"
}
`
	modified := string(originalContent) + indicator

	return os.WriteFile(sandboxTmuxConf, []byte(modified), 0o644)
}
