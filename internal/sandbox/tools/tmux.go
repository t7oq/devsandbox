package tools

import (
	"os"
	"os/exec"
	"path/filepath"
)

func init() {
	Register(&Tmux{})
}

// Tmux provides tmux terminal multiplexer configuration.
// Can display sandbox indicator in status bar.
type Tmux struct{}

func (t *Tmux) Name() string {
	return "tmux"
}

func (t *Tmux) Description() string {
	return "Tmux terminal multiplexer with sandbox indicator"
}

func (t *Tmux) Available(homeDir string) bool {
	// Check if tmux is installed and user has a config
	if _, err := exec.LookPath("tmux"); err != nil {
		return false
	}

	// Check for tmux config
	paths := []string{
		filepath.Join(homeDir, ".tmux.conf"),
		filepath.Join(homeDir, ".config", "tmux", "tmux.conf"),
	}

	for _, p := range paths {
		if _, err := os.Stat(p); err == nil {
			return true
		}
	}

	return false
}

func (t *Tmux) Bindings(homeDir, sandboxHome string) []Binding {
	sandboxTmuxConf := filepath.Join(sandboxHome, ".tmux.conf")

	bindings := []Binding{
		// Tmux plugins (tpm)
		{
			Source:   filepath.Join(homeDir, ".tmux", "plugins"),
			ReadOnly: true,
			Optional: true,
		},
		{
			Source:   filepath.Join(homeDir, ".config", "tmux", "plugins"),
			ReadOnly: true,
			Optional: true,
		},
	}

	// Use sandbox tmux config if setup ran successfully
	if _, err := os.Stat(sandboxTmuxConf); err == nil {
		bindings = append(bindings, Binding{
			Source:   sandboxTmuxConf,
			Dest:     filepath.Join(homeDir, ".tmux.conf"),
			ReadOnly: true,
			Optional: true,
		})
	} else {
		// Fall back to original configs
		bindings = append(bindings,
			Binding{
				Source:   filepath.Join(homeDir, ".tmux.conf"),
				ReadOnly: true,
				Optional: true,
			},
			Binding{
				Source:   filepath.Join(homeDir, ".config", "tmux", "tmux.conf"),
				ReadOnly: true,
				Optional: true,
			},
		)
	}

	return bindings
}

func (t *Tmux) Environment(homeDir, sandboxHome string) []EnvVar {
	return nil
}

func (t *Tmux) ShellInit(shell string) string {
	return ""
}

func (t *Tmux) Check(homeDir string) CheckResult {
	result := CheckBinary("tmux", "Install via system package manager")
	if !result.Available {
		return result
	}

	// Check config paths - tmux requires config to be available
	result.AddConfigPaths(
		filepath.Join(homeDir, ".tmux.conf"),
		filepath.Join(homeDir, ".config", "tmux", "tmux.conf"),
		filepath.Join(homeDir, ".tmux", "plugins"),
	)

	if len(result.ConfigPaths) == 0 {
		result.Available = false
		result.AddIssue("no tmux config found")
	}

	return result
}

// Setup implements ToolWithSetup to generate the sandbox-aware tmux config.
func (t *Tmux) Setup(homeDir, sandboxHome string) error {
	// Find existing tmux config
	configPaths := []string{
		filepath.Join(homeDir, ".tmux.conf"),
		filepath.Join(homeDir, ".config", "tmux", "tmux.conf"),
	}

	var srcPath string
	for _, p := range configPaths {
		if _, err := os.Stat(p); err == nil {
			srcPath = p
			break
		}
	}

	if srcPath == "" {
		return nil
	}

	destPath := filepath.Join(sandboxHome, ".tmux.conf")

	indicator := `

# Sandbox indicator (auto-generated by devsandbox)
# Shows [SANDBOX] in status bar when DEVSANDBOX is set
if-shell '[ -n "$DEVSANDBOX" ]' {
  set -g status-left "#[fg=red,bold][SANDBOX] #[default]#{status-left}"
  set -g status-style "bg=colour52"
}
`
	return SetupConfigWithSuffix(srcPath, destPath, indicator)
}
